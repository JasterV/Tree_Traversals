\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{vmargin}
\setmarginsrb{3 cm }{ 2.5cm }{3 cm }{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}
\title{Binarytree}
\author{Martin, Francisco Manuel \\
        Martinez, Victor
}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother
\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}
%\addto\captionspanish{
\renewcommand*\contentsname{Índex}%}
\setlength{\parindent}{1cm}

\begin{document}
    \begin{titlepage}
	\centering
    \vspace*{0.5 cm}

    \textsc{\LARGE Universidad Politécnica de Lleida}\\[2.0 cm]	% University Name
	\textsc{\large Practica 5}\\[0.5 cm]				% Course Name
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]

	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
			\emph{Author:}\\
			\theauthor
			\end{flushleft}
			\end{minipage}~
			\begin{minipage}{0.4\textwidth}
			\begin{flushright} \large
			\emph{DNI:} \\
			48057095k \\
			84848893x% Your Student Number
		\end{flushright}
	\end{minipage}\\[2 cm]

	{\large \thedate}\\[2 cm]

	\vfill

\end{titlepage}
\tableofcontents
\pagebreak
\section{Introducción}
\section{Tarea 1: Implementación de los arboles binarios}
    \subsection{Constructores}
    Para generar la rama \textit{left} y la rama \textit{right} que
    generan un nuevo árbol a partir del nodo \textit{root} creamos el
    constructor como se recomienda en la documentación de la practica de la
    siguiente forma.
\begin{lstlisting}[lenguage = Java]
this.root = root;
\end{lstlisting}
    \subsection{\textit{equals}}
        \subsubsection{\textit{equals} para Arboles binarios}
            Para comenzar comprobamos que el \textit{object} sea instancia de
            \textit{LinkedBinaryTree} si no lo es devuelve \textbf{false} si no hacemos
            un cast de object a un \textit{LinkedBinaryTree}. 
            Siguiendo con el orden de ejecución llamamos a la función recursiva
            que apartir de la root de los dos arboles comprobara si son el mismo.
    \subsubsection{\textit{equals} para Nodos}
            De nuevo como en la otra implementación de equals hacemos
            \textit{instanceof} esta vez de \textit{Node} y cast para llamar a la misma
            función recursiva que llamamos para \textit{LinkedBinaryTree}.
    \subsubsection{Función recEquals}
            Esta función auxiliar, que llamamos tanto en el equals para arboles o
            para nodos, de forma recursiva comprueba si dos nodos
            son los mismos apartir del root comprobando sus ramas derecha e izquierda y
            comparándolas en el momento que alguno de sus hijos no sea igual
            evaluara a falso.
            \newline
\section{Tarea 2: Recorridos iterativos en árboles binarios}
    \subsection{Interfaz Traversals}
    \textbf{ ¿Qué diferencias provocaría que la interfaz fuera genérica y los
        métodos no?}\\
            En el caso que tenemos los métodos son genéricos i por ello aunque la
            \textit{interface} no es genérica podemos trabajar con todos los elementos
            que contiene \textit{Binarytree}. En el caso contrario no declaras un
            parámetro de tipo que esto conllevara a que estarás sujeto al tipo
            donde instanciamos la clase \textit{traversals}.
       \subsection{Clase Iterative Traversals}

            En esta implementación como indica en la documentación de la
            practica, usaremos la forma imperativa del recorrido haciendo uso
            de una pila tal como lo haría la maquina virtual de Java.
        \subsubsection{Preorden}
        Este recorrido recuerda al algoritmo \textit{DFS} donde hace un búsqueda
        en profundidad, al alcanzar la hoja mas a la izquierda busca en la pila
        la hoja derecha si no la encuentra busca el nodo superior a este y busca
        su nodo derecho y así hasta eliminar de la pila todos los nodos.
        \subsubsection{Inorder}
        Este recorrido consiste en localizar la hoja mas a la izquierda y
        comenzar la lista desde allí después de localizar la hoja visitamos el
        nodo superior y el elemento derecho no lo incluiremos en la lista hasta
        llegar al la hoja izquierda de ese nodo.
        \subsubsection{Postorder}
        En este usa la pila para cargar los nodos hermanos que visitaremos antes
        de visitar al padre, por eso en la lista almacenamos la ultima hoja y
        cargamos en la pila las ramas de su \textit{root} y al así almacenamos
        en la pila las funciones para recorrer hermanos antes que al padre.

\section{Tarea 3: Reconstrucción del árbol binario}
Para esta implementación los dos miembros del grupo hicimos dos variantes una
usando punteros y otra con sublistas. En el caso de los punteros nos resulto muy
difícil realizarlo, teníamos que comprobar muchos casos donde los punteros se
salían del indexó, al final optamos por la implementación mas simple que requería
usar sublistas estas eliminaban el problema con los índices.

Esta implementación se sustenta apartir del razonamiento en el cual tomamos como
primer elemento el root del árbol del ultimo elemento de \textit{postorden} y
buscamos este mismo elemento en \textbf{inorden}, los elementos por la izquierda formaran
parte del arboles izquierdo y el derecho de los elementos de la derecha, el
indexó donde se encuentra este elemento los usaremos como herramienta de corte
para las sublistas ya que marca el inicio de un árbol y su final. Hacemos este
algoritmo de forma recursiva i así alcanzamos a formar el árbol apartir de las
dos listas.
\section{Conclusiones}
En esta practica hemos aprendido mucho sobre el comportamiento de genéricos
apartir de uno de los errores que cometimos en el primer apartado, en este
apartado pretendíamos hacer un cast de \textit{object} usando los comodines
\textbf{<E>} hasta darnos cuenta que no podríamos usarlos, todo sucedió por que
el compilador no nos devolvía ningún error. Cambiamos los comodines a
\textbf{<?>} para poder hacer el cast. Pero estuvimos investigando el porque que
hacia que nuestro cast no se quejaba haciendo test exhaustivos para encontrar el
error.

Otro aprendizaje valioso surjio en la tarea tres cuando queriamos ver si suponia
un sobre coste el uso de sublistas en lugar de indices porque en un principio
creiamos que este uso haria una duplicacion de listas. Despues de repasar el
codigo usado en las sublistas vimos que con el uso de indices como en nuestra
idea, permitia hacer vistas a la lista original y cuando hacias una sublista de
una sublista hacias una vista de la sublista que apuntaba a la lista original.


\end{document}
